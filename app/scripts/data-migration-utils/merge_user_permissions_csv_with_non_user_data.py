#!/usr/bin/env python
import json
import csv
import sys
import hashlib
import base64
from datetime import datetime

# This utility takes two input files:
# 1) Read from STDIN: CSV of user permissions data:
#      Subject (fullpath), User (fullpath), User Data (e.g. 'salt')
# 2) First command line argument: filename of Timetable data dump for reference
#      (a JSON file of the format generated by "manage.py dumpdata timetables")
#
# e.g. cat playserver_userperms.csv | \
#       python merge_user_permissions_csv_with_non_user_data.py liveserver.dump
#
# This utility takes those two files and generates output that can be used by
# "manage.py loaddata" to populate another instance of Timetable.
# Specifically, it translates the user permissions supplied in CSV format into
# Timetable objects, using Primary Keys taken from the supplied dump file.

# Read JSON file
nonuserdatafilename = sys.argv[1]
nonuserdata = None
with open(nonuserdatafilename, "rb") as jsonfile:
    nonuserdata = json.load(jsonfile)
    jsonfile.close()

# Read CSV file
reader = csv.reader(sys.stdin, dialect=csv.excel)
perms = []
for row in reader:
    # subjectpath, userpath, userdata
    perms.append((row[0], row[1], row[2]))


# Analyse the JSON input to facilitate looking up
# Primary Keys etc
def isThing(obj):
    return obj["model"] == "timetables.thing"

things = filter(isThing, nonuserdata)

fullpath2pk = {}
highestthingpk = 0
for thing in things:
    fullpath = thing["fields"]["fullpath"]
    pk = thing["pk"]
    highestthingpk = max(highestthingpk, pk)
    fullpath2pk[fullpath] = pk


# Iterate through the CSV input, translating user permissions into ThingTag
# objects, and collating users that need to be generated in the following step
missingsubjectcounts = {}
userpks = {}
userpath2data = {}
thingtags = []
nextthingpk = highestthingpk + 1
nextthingtagpk = 1
for perm in perms:
    subjectpath = perm[0]
    userpath = perm[1]
    userdata = perm[2]
    userpath2data[userpath] = userdata
    userpk = None
    if userpath not in userpks:
        userpks[userpath] = nextthingpk
        nextthingpk += 1
    userpk = userpks[userpath]
    try:
        subjectpk = fullpath2pk[subjectpath]
        thingtag = {}
        thingtag["pk"] = nextthingtagpk
        thingtag["model"] = "timetables.thingtag"
        thingtag["fields"] = {
            "annotation": "admin",
            "targetthing": subjectpk,
            "thing": userpk
        }
        thingtags.append(thingtag)
        nextthingtagpk += 1
    except KeyError:
        if subjectpath in missingsubjectcounts:
            missingsubjectcounts[subjectpath] += 1
        else:
            missingsubjectcounts[subjectpath] = 1


# Now generate the Thing objects for each user mentioned in the CSV


def hash(key):
    # From models.py HierarchicalModel
    m = hashlib.sha1()
    m.update(key)
    return base64.urlsafe_b64encode(m.digest())

parentuserpk = fullpath2pk["user"]
userthings = []
for userpath in sorted(userpks.keys(), key=lambda pk: userpks[pk]):
    username = userpath[5:]
    pathid = hash(userpath)
    data = userpath2data[userpath]
    userthing = {}
    userthing["pk"] = userpks[userpath]
    userthing["model"] = "timetables.thing"
    userthing["fields"] = {
        "data": data,
        "fullname": "A Users Calendar",
        "fullpath": userpath,
        "name": username,
        "parent": parentuserpk,
        "pathid": pathid,
        "type": "user"
    }
    userthings.append(userthing)

# Finally we're ready to output the results and any errors
output = userthings + thingtags

json.dump(output, sys.stdout, sort_keys=True, indent=4)
print

if len(missingsubjectcounts.keys()) == 0:
    print >> sys.stderr, "Merged fine with no mismatches!"
else:
    print >> sys.stderr, "The following subject fullpaths in the CSV were not found in the JSON, and were skipped."
    print >> sys.stderr, "The numbers show how many users had permissions to edit each skipped subject."
    print >> sys.stderr, "Please refer back to the original CSV to find the actual usernames."
    json.dump(missingsubjectcounts, sys.stderr, sort_keys=True, indent=4)
    print >> sys.stderr  # add a newline
